/**
 * MailSlurp API Documentation
 * [MailSlurp](https://www.mailslurp.com) is an end-to-end email testing service. It has a [web-app](https://www.mailslurp.com/dashboard) for managing your account and a [REST API](https://api.mailslurp.com) for sending and receiving emails from randomly generated email addresses.  ## Why? MailSlurp was built to test the integration of email services within an app. If your application relies on the sending or receiving of emails, then MailSlurp will let you test that functionality. This is a more common need than you might think: if your app has a sign up process that requires email verification, how do you currently test that?  ## Getting started - [API Docs](https://www.mailslurp.com/documentation) - [Code Examples](https://www.mailslurp.com/documentation/examples) - [Swagger Definition](https://api.mailslurp.com/v2/api-docs)  Every API request requires a valid API Key appended as a query parameter. [To obtain an API Key visit your account dashboard](https://www.mailslurp.com/dashboard).    The general flow is as follows:  - Create a new inbox during a test. The email address will be returned in the response.  - Send an email to that address or trigger an action in your test that does so. - Fetch the email for your new inbox and check if its content is what you expected, or use the content in another action.  ## SDK - There is an official [Javascript SDK](https://www.npmjs.com/package/mailslurp-client) available on npm. - You can also use the [swagger JSON definition](https://api.mailslurp.com/v2/api-docs) and [swagger-codegen](https://github.com/swagger-api/swagger-codegen) to generate a swagger client in a language of your choice.  ## Legal The Mailslurp API code is owned by [PettmanUG](http://pettmanug.site) and uses a proprietary [software licence](http://www.binpress.com/license/view/l/c8376a01eca7465027a978d3fde5a1e2). The SDKs are free to use in any project and have an ISC licence.  ## Bugs, features, support To report bugs or request features please see the [contact page](https://www.mailslurp.com/contact). For help see [support](https://www.mailslurp.com/support).
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.mailslurp.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AccountDto {
    'accountType': AccountDto.AccountTypeEnum;
    'limit': string;
    'priceCents': number;
    'priceString': string;
    'stripeProduct': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "AccountDto.AccountTypeEnum"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "string"
        },
        {
            "name": "priceCents",
            "baseName": "priceCents",
            "type": "number"
        },
        {
            "name": "priceString",
            "baseName": "priceString",
            "type": "string"
        },
        {
            "name": "stripeProduct",
            "baseName": "stripeProduct",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountDto.attributeTypeMap;
    }
}

export namespace AccountDto {
    export enum AccountTypeEnum {
        FREE = <any> 'FREE',
        PAID = <any> 'PAID'
    }
}
export class AccountsDto {
    'free': AccountDto;
    'paid': AccountDto;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "free",
            "baseName": "free",
            "type": "AccountDto"
        },
        {
            "name": "paid",
            "baseName": "paid",
            "type": "AccountDto"
        }    ];

    static getAttributeTypeMap() {
        return AccountsDto.attributeTypeMap;
    }
}

export class EmailDto {
    'body': string;
    'from': string;
    'id': string;
    'received': Date;
    'returnPath': string;
    'subject': string;
    'to': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "received",
            "baseName": "received",
            "type": "Date"
        },
        {
            "name": "returnPath",
            "baseName": "returnPath",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return EmailDto.attributeTypeMap;
    }
}

export class InboxDto {
    'address': string;
    'id': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InboxDto.attributeTypeMap;
    }
}

export class Response {
    'message': string;
    'payload': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Response.attributeTypeMap;
    }
}

export class ResponseInboxDto {
    'message': string;
    'payload': InboxDto;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "InboxDto"
        }    ];

    static getAttributeTypeMap() {
        return ResponseInboxDto.attributeTypeMap;
    }
}

export class ResponseListEmailDto {
    'message': string;
    'payload': Array<EmailDto>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "Array<EmailDto>"
        }    ];

    static getAttributeTypeMap() {
        return ResponseListEmailDto.attributeTypeMap;
    }
}

export class ResponseListInboxDto {
    'message': string;
    'payload': Array<InboxDto>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "Array<InboxDto>"
        }    ];

    static getAttributeTypeMap() {
        return ResponseListInboxDto.attributeTypeMap;
    }
}

export class SendEmailDto {
    'body': string;
    'subject': string;
    'to': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendEmailDto.attributeTypeMap;
    }
}

export class UserDto {
    'accountType': UserDto.AccountTypeEnum;
    'apiKey': string;
    'newUser': boolean;
    'uuid': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "UserDto.AccountTypeEnum"
        },
        {
            "name": "apiKey",
            "baseName": "apiKey",
            "type": "string"
        },
        {
            "name": "newUser",
            "baseName": "newUser",
            "type": "boolean"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserDto.attributeTypeMap;
    }
}

export namespace UserDto {
    export enum AccountTypeEnum {
        FREE = <any> 'FREE',
        PAID = <any> 'PAID'
    }
}

let enumsMap: {[index: string]: any} = {
        "AccountDto.AccountTypeEnum": AccountDto.AccountTypeEnum,
        "UserDto.AccountTypeEnum": UserDto.AccountTypeEnum,
}

let typeMap: {[index: string]: any} = {
    "AccountDto": AccountDto,
    "AccountsDto": AccountsDto,
    "EmailDto": EmailDto,
    "InboxDto": InboxDto,
    "Response": Response,
    "ResponseInboxDto": ResponseInboxDto,
    "ResponseListEmailDto": ResponseListEmailDto,
    "ResponseListInboxDto": ResponseListInboxDto,
    "SendEmailDto": SendEmailDto,
    "UserDto": UserDto,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountControllerApiApiKeys {
}

export class AccountControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountControllerApiApiKeys, value: string) {
        (this.authentications as any)[AccountControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * For use in dashboard
     * @summary Upgrade a user to paid
     * @param jwtToken Cognito ID obtained during login
     * @param stripeToken Stripe user payment confirmation token
     */
    public createSubscriptionUsingPOST (jwtToken: string, stripeToken: string) : Promise<{ response: http.ClientResponse; body: UserDto;  }> {
        const localVarPath = this.basePath + '/subscription';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jwtToken' is not null or undefined
        if (jwtToken === null || jwtToken === undefined) {
            throw new Error('Required parameter jwtToken was null or undefined when calling createSubscriptionUsingPOST.');
        }

        // verify required parameter 'stripeToken' is not null or undefined
        if (stripeToken === null || stripeToken === undefined) {
            throw new Error('Required parameter stripeToken was null or undefined when calling createSubscriptionUsingPOST.');
        }

        if (jwtToken !== undefined) {
            localVarQueryParameters['jwtToken'] = ObjectSerializer.serialize(jwtToken, "string");
        }

        if (stripeToken !== undefined) {
            localVarQueryParameters['stripeToken'] = ObjectSerializer.serialize(stripeToken, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * For use in dashboard
     * @summary List available account types
     */
    public getAccountsUsingGET () : Promise<{ response: http.ClientResponse; body: AccountsDto;  }> {
        const localVarPath = this.basePath + '/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccountsDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountsDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InboxControllerApiApiKeys {
}

export class InboxControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InboxControllerApiApiKeys, value: string) {
        (this.authentications as any)[InboxControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new random inbox and return the id and email address for it. Send emails to this address and they will be stored for this inbox.
     * @summary Create an inbox
     * @param apiKey Your API Key. Sign up and find it in your dashboard.
     */
    public createRandomInboxUsingPOST (apiKey: string) : Promise<{ response: http.ClientResponse; body: ResponseInboxDto;  }> {
        const localVarPath = this.basePath + '/inboxes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling createRandomInboxUsingPOST.');
        }

        if (apiKey !== undefined) {
            localVarQueryParameters['apiKey'] = ObjectSerializer.serialize(apiKey, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseInboxDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseInboxDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an inbox and all the emails associated with it.
     * @summary Delete an inbox
     * @param apiKey Your API Key. Sign up and find it in your dashboard.
     * @param uuid The inbox&#39;s id.
     */
    public deleteInboxUsingDELETE (apiKey: string, uuid: string) : Promise<{ response: http.ClientResponse; body: Response;  }> {
        const localVarPath = this.basePath + '/inboxes/{uuid}'
            .replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling deleteInboxUsingDELETE.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling deleteInboxUsingDELETE.');
        }

        if (apiKey !== undefined) {
            localVarQueryParameters['apiKey'] = ObjectSerializer.serialize(apiKey, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of emails stored in a given inbox. Each email contains various properties including the email body (in eml format), subject, and sender. The `since` parameter is a ISO8601 LocalDateTime that will filter for emails received on or after the given DateTime. Note that because an inbox may take 5 to 10 seconds to receive an email, you can use the `waitFor` parameter to hold a request open until the desired number of emails is present. If this number is not met after 100 seconds, an error will be returned.
     * @summary Fetch emails for a given inbox
     * @param apiKey Your API Key. Sign up and find it in your dashboard.
     * @param uuid The inbox&#39;s id.
     * @param minCount Wait a maximum of 100 seconds for atleast this many emails in an inbox before returning a result.
     * @param maxWait Maximum seconds API should spend retrying your inbox until the minCount is satisfied
     * @param since Filter for emails received on or after this ISO8601 LocalDateTime.
     */
    public getEmailsForInboxUsingGET (apiKey: string, uuid: string, minCount?: number, maxWait?: number, since?: Date) : Promise<{ response: http.ClientResponse; body: ResponseListEmailDto;  }> {
        const localVarPath = this.basePath + '/inboxes/{uuid}'
            .replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling getEmailsForInboxUsingGET.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling getEmailsForInboxUsingGET.');
        }

        if (apiKey !== undefined) {
            localVarQueryParameters['apiKey'] = ObjectSerializer.serialize(apiKey, "string");
        }

        if (minCount !== undefined) {
            localVarQueryParameters['minCount'] = ObjectSerializer.serialize(minCount, "number");
        }

        if (maxWait !== undefined) {
            localVarQueryParameters['maxWait'] = ObjectSerializer.serialize(maxWait, "number");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseListEmailDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseListEmailDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of your inboxes. Each inbox has a uuid and an email address. Emails sent to the email address are stored in the inbox and can be fetched via `/inboxes/{uuid}`.
     * @summary List your inboxes
     * @param apiKey Your API Key. Sign up and find it in your dashboard.
     */
    public getListOfInboxesUsingGET (apiKey: string) : Promise<{ response: http.ClientResponse; body: ResponseListInboxDto;  }> {
        const localVarPath = this.basePath + '/inboxes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling getListOfInboxesUsingGET.');
        }

        if (apiKey !== undefined) {
            localVarQueryParameters['apiKey'] = ObjectSerializer.serialize(apiKey, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseListInboxDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseListInboxDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send an email from the given inbox's email address. Useful if you need to test a user contacting you, for instance.
     * @summary Send an email
     * @param apiKey Your API Key. Sign up and find it in your dashboard.
     * @param uuid The inbox&#39;s id.
     * @param sendEmailDto The email to send.
     */
    public sendEmailFromUserUsingPOST (apiKey: string, uuid: string, sendEmailDto: SendEmailDto) : Promise<{ response: http.ClientResponse; body: Response;  }> {
        const localVarPath = this.basePath + '/inboxes/{uuid}'
            .replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling sendEmailFromUserUsingPOST.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling sendEmailFromUserUsingPOST.');
        }

        // verify required parameter 'sendEmailDto' is not null or undefined
        if (sendEmailDto === null || sendEmailDto === undefined) {
            throw new Error('Required parameter sendEmailDto was null or undefined when calling sendEmailFromUserUsingPOST.');
        }

        if (apiKey !== undefined) {
            localVarQueryParameters['apiKey'] = ObjectSerializer.serialize(apiKey, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendEmailDto, "SendEmailDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserControllerApiApiKeys {
}

export class UserControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserControllerApiApiKeys, value: string) {
        (this.authentications as any)[UserControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * Used by the dashboard to fetch user information.
     * @summary Fetch a user
     * @param jwtToken Cognito ID obtained during login
     */
    public getUserUsingGET (jwtToken: string) : Promise<{ response: http.ClientResponse; body: UserDto;  }> {
        const localVarPath = this.basePath + '/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'jwtToken' is not null or undefined
        if (jwtToken === null || jwtToken === undefined) {
            throw new Error('Required parameter jwtToken was null or undefined when calling getUserUsingGET.');
        }

        if (jwtToken !== undefined) {
            localVarQueryParameters['jwtToken'] = ObjectSerializer.serialize(jwtToken, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
