/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MailSlurp API Documentation
 * [MailSlurp](https://www.mailslurp.com) is an end-to-end email testing service. It has a [web-app](https://www.mailslurp.com/dashboard) for managing your account and a [REST API](https://api.mailslurp.com) for sending and receiving emails from randomly generated email addresses.  ## Why? MailSlurp was built to test the integration of email services within an app. If your application relies on the sending or receiving of emails, then MailSlurp will let you test that functionality. This is a more common need than you might think: if your app has a sign up process that requires email verification, how do you currently test that?  ## Getting started - [API Docs](https://www.mailslurp.com/documentation) - [Code Examples](https://www.mailslurp.com/documentation/examples) - [Swagger Definition](https://api.mailslurp.com/v2/api-docs)  Every API request requires a valid API Key appended as a query parameter. [To obtain an API Key visit your account dashboard](https://www.mailslurp.com/dashboard).    The general flow is as follows:  - Create a new inbox during a test. The email address will be returned in the apiReponse. - Send an email to that address or trigger an action in your test that does so. - Fetch the email for your new inbox and check if its content is what you expected, or use the content in another action.  ## SDK - There is an official [Javascript SDK](https://www.npmjs.com/package/mailslurp-client) available on npm. - You can also use the [swagger JSON definition](https://api.mailslurp.com/v2/api-docs) and [swagger-codegen](https://github.com/swagger-api/swagger-codegen) to generate a swagger client in a language of your choice.  ## Legal The Mailslurp API code is owned by [PettmanUG](http://pettmanug.site) and uses a proprietary [software licence](http://www.binpress.com/license/view/l/c8376a01eca7465027a978d3fde5a1e2). The SDKs are free to use in any project and have an ISC licence.  ## Bugs, features, support To report bugs or request features please see the [contact page](https://www.mailslurp.com/contact). For help see [support](https://www.mailslurp.com/support).
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.mailslurp.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AccountDto
 */
export interface AccountDto {
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    accountType?: AccountDto.AccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    limit?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountDto
     */
    priceCents?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    priceString?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    stripeProduct?: string;
}

/**
 * @export
 * @namespace AccountDto
 */
export namespace AccountDto {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        FREE = <any> 'FREE',
        PAID = <any> 'PAID'
    }
}

/**
 * 
 * @export
 * @interface AccountsDto
 */
export interface AccountsDto {
    /**
     * 
     * @type {AccountDto}
     * @memberof AccountsDto
     */
    free?: AccountDto;
    /**
     * 
     * @type {AccountDto}
     * @memberof AccountsDto
     */
    paid?: AccountDto;
}

/**
 * 
 * @export
 * @interface ApiReponse
 */
export interface ApiReponse {
    /**
     * 
     * @type {string}
     * @memberof ApiReponse
     */
    message?: string;
    /**
     * 
     * @type {any}
     * @memberof ApiReponse
     */
    payload?: any;
}

/**
 * 
 * @export
 * @interface ApiReponseInboxDto
 */
export interface ApiReponseInboxDto {
    /**
     * 
     * @type {string}
     * @memberof ApiReponseInboxDto
     */
    message?: string;
    /**
     * 
     * @type {InboxDto}
     * @memberof ApiReponseInboxDto
     */
    payload?: InboxDto;
}

/**
 * 
 * @export
 * @interface ApiReponseListEmailDto
 */
export interface ApiReponseListEmailDto {
    /**
     * 
     * @type {string}
     * @memberof ApiReponseListEmailDto
     */
    message?: string;
    /**
     * 
     * @type {Array&lt;EmailDto&gt;}
     * @memberof ApiReponseListEmailDto
     */
    payload?: Array<EmailDto>;
}

/**
 * 
 * @export
 * @interface ApiReponseListInboxDto
 */
export interface ApiReponseListInboxDto {
    /**
     * 
     * @type {string}
     * @memberof ApiReponseListInboxDto
     */
    message?: string;
    /**
     * 
     * @type {Array&lt;InboxDto&gt;}
     * @memberof ApiReponseListInboxDto
     */
    payload?: Array<InboxDto>;
}

/**
 * 
 * @export
 * @interface EmailDto
 */
export interface EmailDto {
    /**
     * 
     * @type {string}
     * @memberof EmailDto
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDto
     */
    from?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDto
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof EmailDto
     */
    received?: Date;
    /**
     * 
     * @type {string}
     * @memberof EmailDto
     */
    returnPath?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDto
     */
    subject?: string;
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof EmailDto
     */
    to?: Array<string>;
}

/**
 * 
 * @export
 * @interface InboxDto
 */
export interface InboxDto {
    /**
     * 
     * @type {string}
     * @memberof InboxDto
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof InboxDto
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface SendEmailDto
 */
export interface SendEmailDto {
    /**
     * 
     * @type {string}
     * @memberof SendEmailDto
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof SendEmailDto
     */
    subject?: string;
    /**
     * 
     * @type {string}
     * @memberof SendEmailDto
     */
    to?: string;
}

/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    accountType?: UserDto.AccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    apiKey?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDto
     */
    newUser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    uuid?: string;
}

/**
 * @export
 * @namespace UserDto
 */
export namespace UserDto {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        FREE = <any> 'FREE',
        PAID = <any> 'PAID'
    }
}


/**
 * AccountControllerApi - fetch parameter creator
 * @export
 */
export const AccountControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For use in dashboard
         * @summary Upgrade a user to paid
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {string} stripeToken Stripe user payment confirmation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionUsingPOST(jwtToken: string, stripeToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'jwtToken' is not null or undefined
            if (jwtToken === null || jwtToken === undefined) {
                throw new RequiredError('jwtToken','Required parameter jwtToken was null or undefined when calling createSubscriptionUsingPOST.');
            }
            // verify required parameter 'stripeToken' is not null or undefined
            if (stripeToken === null || stripeToken === undefined) {
                throw new RequiredError('stripeToken','Required parameter stripeToken was null or undefined when calling createSubscriptionUsingPOST.');
            }
            const localVarPath = `/subscription`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jwtToken !== undefined) {
                localVarQueryParameter['jwtToken'] = jwtToken;
            }

            if (stripeToken !== undefined) {
                localVarQueryParameter['stripeToken'] = stripeToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For use in dashboard
         * @summary List available account types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountControllerApi - functional programming interface
 * @export
 */
export const AccountControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * For use in dashboard
         * @summary Upgrade a user to paid
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {string} stripeToken Stripe user payment confirmation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionUsingPOST(jwtToken: string, stripeToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDto> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).createSubscriptionUsingPOST(jwtToken, stripeToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * For use in dashboard
         * @summary List available account types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountsDto> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).getAccountsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountControllerApi - factory interface
 * @export
 */
export const AccountControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * For use in dashboard
         * @summary Upgrade a user to paid
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {string} stripeToken Stripe user payment confirmation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionUsingPOST(jwtToken: string, stripeToken: string, options?: any) {
            return AccountControllerApiFp(configuration).createSubscriptionUsingPOST(jwtToken, stripeToken, options)(fetch, basePath);
        },
        /**
         * For use in dashboard
         * @summary List available account types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsUsingGET(options?: any) {
            return AccountControllerApiFp(configuration).getAccountsUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * AccountControllerApi - object-oriented interface
 * @export
 * @class AccountControllerApi
 * @extends {BaseAPI}
 */
export class AccountControllerApi extends BaseAPI {
    /**
     * For use in dashboard
     * @summary Upgrade a user to paid
     * @param {} jwtToken Cognito ID obtained during login
     * @param {} stripeToken Stripe user payment confirmation token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public createSubscriptionUsingPOST(jwtToken: string, stripeToken: string, options?: any) {
        return AccountControllerApiFp(this.configuration).createSubscriptionUsingPOST(jwtToken, stripeToken, options)(this.fetch, this.basePath);
    }

    /**
     * For use in dashboard
     * @summary List available account types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public getAccountsUsingGET(options?: any) {
        return AccountControllerApiFp(this.configuration).getAccountsUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * InboxControllerApi - fetch parameter creator
 * @export
 */
export const InboxControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new random inbox and return the id and email address for it. Send emails to this address and they will be stored for this inbox.
         * @summary Create an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandomInboxUsingPOST(apiKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling createRandomInboxUsingPOST.');
            }
            const localVarPath = `/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an inbox and all the emails associated with it.
         * @summary Delete an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInboxUsingDELETE(apiKey: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling deleteInboxUsingDELETE.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteInboxUsingDELETE.');
            }
            const localVarPath = `/inboxes/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of emails stored in a given inbox. Each email contains various properties including the email body (in eml format), subject, and sender. The `since` parameter is a ISO8601 LocalDateTime that will filter for emails received on or after the given DateTime. Note that because an inbox may take 5 to 10 seconds to receive an email, you can use the `waitFor` parameter to hold a request open until the desired number of emails is present. If this number is not met after 100 seconds, an error will be returned.
         * @summary Fetch emails for a given inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {number} [minCount] Wait a maximum of 100 seconds for atleast this many emails in an inbox before returning a result.
         * @param {number} [maxWait] Maximum seconds API should spend retrying your inbox until the minCount is satisfied
         * @param {Date} [since] Filter for emails received on or after this ISO8601 LocalDateTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsForInboxUsingGET(apiKey: string, uuid: string, minCount?: number, maxWait?: number, since?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling getEmailsForInboxUsingGET.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getEmailsForInboxUsingGET.');
            }
            const localVarPath = `/inboxes/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            if (minCount !== undefined) {
                localVarQueryParameter['minCount'] = minCount;
            }

            if (maxWait !== undefined) {
                localVarQueryParameter['maxWait'] = maxWait;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of your inboxes. Each inbox has a uuid and an email address. Emails sent to the email address are stored in the inbox and can be fetched via `/inboxes/{uuid}`.
         * @summary List your inboxes
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfInboxesUsingGET(apiKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling getListOfInboxesUsingGET.');
            }
            const localVarPath = `/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from the given inbox's email address. Useful if you need to test a user contacting you, for instance.
         * @summary Send an email
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {SendEmailDto} sendEmailDto The email to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailFromUserUsingPOST(apiKey: string, uuid: string, sendEmailDto: SendEmailDto, options: any = {}): FetchArgs {
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling sendEmailFromUserUsingPOST.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling sendEmailFromUserUsingPOST.');
            }
            // verify required parameter 'sendEmailDto' is not null or undefined
            if (sendEmailDto === null || sendEmailDto === undefined) {
                throw new RequiredError('sendEmailDto','Required parameter sendEmailDto was null or undefined when calling sendEmailFromUserUsingPOST.');
            }
            const localVarPath = `/inboxes/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendEmailDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sendEmailDto || {}) : (sendEmailDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InboxControllerApi - functional programming interface
 * @export
 */
export const InboxControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new random inbox and return the id and email address for it. Send emails to this address and they will be stored for this inbox.
         * @summary Create an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandomInboxUsingPOST(apiKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiReponseInboxDto> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).createRandomInboxUsingPOST(apiKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an inbox and all the emails associated with it.
         * @summary Delete an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInboxUsingDELETE(apiKey: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiReponse> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).deleteInboxUsingDELETE(apiKey, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of emails stored in a given inbox. Each email contains various properties including the email body (in eml format), subject, and sender. The `since` parameter is a ISO8601 LocalDateTime that will filter for emails received on or after the given DateTime. Note that because an inbox may take 5 to 10 seconds to receive an email, you can use the `waitFor` parameter to hold a request open until the desired number of emails is present. If this number is not met after 100 seconds, an error will be returned.
         * @summary Fetch emails for a given inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {number} [minCount] Wait a maximum of 100 seconds for atleast this many emails in an inbox before returning a result.
         * @param {number} [maxWait] Maximum seconds API should spend retrying your inbox until the minCount is satisfied
         * @param {Date} [since] Filter for emails received on or after this ISO8601 LocalDateTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsForInboxUsingGET(apiKey: string, uuid: string, minCount?: number, maxWait?: number, since?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiReponseListEmailDto> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).getEmailsForInboxUsingGET(apiKey, uuid, minCount, maxWait, since, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of your inboxes. Each inbox has a uuid and an email address. Emails sent to the email address are stored in the inbox and can be fetched via `/inboxes/{uuid}`.
         * @summary List your inboxes
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfInboxesUsingGET(apiKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiReponseListInboxDto> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).getListOfInboxesUsingGET(apiKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from the given inbox's email address. Useful if you need to test a user contacting you, for instance.
         * @summary Send an email
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {SendEmailDto} sendEmailDto The email to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailFromUserUsingPOST(apiKey: string, uuid: string, sendEmailDto: SendEmailDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiReponse> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).sendEmailFromUserUsingPOST(apiKey, uuid, sendEmailDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InboxControllerApi - factory interface
 * @export
 */
export const InboxControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new random inbox and return the id and email address for it. Send emails to this address and they will be stored for this inbox.
         * @summary Create an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandomInboxUsingPOST(apiKey: string, options?: any) {
            return InboxControllerApiFp(configuration).createRandomInboxUsingPOST(apiKey, options)(fetch, basePath);
        },
        /**
         * Delete an inbox and all the emails associated with it.
         * @summary Delete an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInboxUsingDELETE(apiKey: string, uuid: string, options?: any) {
            return InboxControllerApiFp(configuration).deleteInboxUsingDELETE(apiKey, uuid, options)(fetch, basePath);
        },
        /**
         * Return a list of emails stored in a given inbox. Each email contains various properties including the email body (in eml format), subject, and sender. The `since` parameter is a ISO8601 LocalDateTime that will filter for emails received on or after the given DateTime. Note that because an inbox may take 5 to 10 seconds to receive an email, you can use the `waitFor` parameter to hold a request open until the desired number of emails is present. If this number is not met after 100 seconds, an error will be returned.
         * @summary Fetch emails for a given inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {number} [minCount] Wait a maximum of 100 seconds for atleast this many emails in an inbox before returning a result.
         * @param {number} [maxWait] Maximum seconds API should spend retrying your inbox until the minCount is satisfied
         * @param {Date} [since] Filter for emails received on or after this ISO8601 LocalDateTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsForInboxUsingGET(apiKey: string, uuid: string, minCount?: number, maxWait?: number, since?: Date, options?: any) {
            return InboxControllerApiFp(configuration).getEmailsForInboxUsingGET(apiKey, uuid, minCount, maxWait, since, options)(fetch, basePath);
        },
        /**
         * Return a list of your inboxes. Each inbox has a uuid and an email address. Emails sent to the email address are stored in the inbox and can be fetched via `/inboxes/{uuid}`.
         * @summary List your inboxes
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfInboxesUsingGET(apiKey: string, options?: any) {
            return InboxControllerApiFp(configuration).getListOfInboxesUsingGET(apiKey, options)(fetch, basePath);
        },
        /**
         * Send an email from the given inbox's email address. Useful if you need to test a user contacting you, for instance.
         * @summary Send an email
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {SendEmailDto} sendEmailDto The email to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailFromUserUsingPOST(apiKey: string, uuid: string, sendEmailDto: SendEmailDto, options?: any) {
            return InboxControllerApiFp(configuration).sendEmailFromUserUsingPOST(apiKey, uuid, sendEmailDto, options)(fetch, basePath);
        },
    };
};

/**
 * InboxControllerApi - object-oriented interface
 * @export
 * @class InboxControllerApi
 * @extends {BaseAPI}
 */
export class InboxControllerApi extends BaseAPI {
    /**
     * Create a new random inbox and return the id and email address for it. Send emails to this address and they will be stored for this inbox.
     * @summary Create an inbox
     * @param {} apiKey Your API Key. Sign up and find it in your dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public createRandomInboxUsingPOST(apiKey: string, options?: any) {
        return InboxControllerApiFp(this.configuration).createRandomInboxUsingPOST(apiKey, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an inbox and all the emails associated with it.
     * @summary Delete an inbox
     * @param {} apiKey Your API Key. Sign up and find it in your dashboard.
     * @param {} uuid The inbox&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public deleteInboxUsingDELETE(apiKey: string, uuid: string, options?: any) {
        return InboxControllerApiFp(this.configuration).deleteInboxUsingDELETE(apiKey, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of emails stored in a given inbox. Each email contains various properties including the email body (in eml format), subject, and sender. The `since` parameter is a ISO8601 LocalDateTime that will filter for emails received on or after the given DateTime. Note that because an inbox may take 5 to 10 seconds to receive an email, you can use the `waitFor` parameter to hold a request open until the desired number of emails is present. If this number is not met after 100 seconds, an error will be returned.
     * @summary Fetch emails for a given inbox
     * @param {} apiKey Your API Key. Sign up and find it in your dashboard.
     * @param {} uuid The inbox&#39;s id.
     * @param {} [minCount] Wait a maximum of 100 seconds for atleast this many emails in an inbox before returning a result.
     * @param {} [maxWait] Maximum seconds API should spend retrying your inbox until the minCount is satisfied
     * @param {} [since] Filter for emails received on or after this ISO8601 LocalDateTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getEmailsForInboxUsingGET(apiKey: string, uuid: string, minCount?: number, maxWait?: number, since?: Date, options?: any) {
        return InboxControllerApiFp(this.configuration).getEmailsForInboxUsingGET(apiKey, uuid, minCount, maxWait, since, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of your inboxes. Each inbox has a uuid and an email address. Emails sent to the email address are stored in the inbox and can be fetched via `/inboxes/{uuid}`.
     * @summary List your inboxes
     * @param {} apiKey Your API Key. Sign up and find it in your dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getListOfInboxesUsingGET(apiKey: string, options?: any) {
        return InboxControllerApiFp(this.configuration).getListOfInboxesUsingGET(apiKey, options)(this.fetch, this.basePath);
    }

    /**
     * Send an email from the given inbox's email address. Useful if you need to test a user contacting you, for instance.
     * @summary Send an email
     * @param {} apiKey Your API Key. Sign up and find it in your dashboard.
     * @param {} uuid The inbox&#39;s id.
     * @param {} sendEmailDto The email to send.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public sendEmailFromUserUsingPOST(apiKey: string, uuid: string, sendEmailDto: SendEmailDto, options?: any) {
        return InboxControllerApiFp(this.configuration).sendEmailFromUserUsingPOST(apiKey, uuid, sendEmailDto, options)(this.fetch, this.basePath);
    }

}

/**
 * UserControllerApi - fetch parameter creator
 * @export
 */
export const UserControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Used by the dashboard to fetch user information.
         * @summary Fetch a user
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET(jwtToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'jwtToken' is not null or undefined
            if (jwtToken === null || jwtToken === undefined) {
                throw new RequiredError('jwtToken','Required parameter jwtToken was null or undefined when calling getUserUsingGET.');
            }
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jwtToken !== undefined) {
                localVarQueryParameter['jwtToken'] = jwtToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Used by the dashboard to fetch user information.
         * @summary Fetch a user
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET(jwtToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDto> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUserUsingGET(jwtToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Used by the dashboard to fetch user information.
         * @summary Fetch a user
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET(jwtToken: string, options?: any) {
            return UserControllerApiFp(configuration).getUserUsingGET(jwtToken, options)(fetch, basePath);
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * Used by the dashboard to fetch user information.
     * @summary Fetch a user
     * @param {} jwtToken Cognito ID obtained during login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserUsingGET(jwtToken: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUserUsingGET(jwtToken, options)(this.fetch, this.basePath);
    }

}

