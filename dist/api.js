"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MailSlurp API Documentation
 * [MailSlurp](https://www.mailslurp.com) is an end-to-end email testing service. It has a [web-app](https://www.mailslurp.com/dashboard) for managing your account and a [REST API](https://api.mailslurp.com) for sending and receiving emails from randomly generated email addresses.  ## Why? MailSlurp was built to test the integration of email services within an app. If your application relies on the sending or receiving of emails, then MailSlurp will let you test that functionality. This is a more common need than you might think: if your app has a sign up process that requires email verification, how do you currently test that?  ## Getting started - [API Docs](https://www.mailslurp.com/documentation) - [Code Examples](https://www.mailslurp.com/documentation/examples) - [Swagger Definition](https://api.mailslurp.com/v2/api-docs)  Every API request requires a valid API Key appended as a query parameter. [To obtain an API Key visit your account dashboard](https://www.mailslurp.com/dashboard).    The general flow is as follows:  - Create a new inbox during a test. The email address will be returned in the apiReponse. - Send an email to that address or trigger an action in your test that does so. - Fetch the email for your new inbox and check if its content is what you expected, or use the content in another action.  ## SDK - There is an official [Javascript SDK](https://www.npmjs.com/package/mailslurp-client) available on npm. - You can also use the [swagger JSON definition](https://api.mailslurp.com/v2/api-docs) and [swagger-codegen](https://github.com/swagger-api/swagger-codegen) to generate a swagger client in a language of your choice.  ## Legal The Mailslurp API code is owned by [PettmanUG](http://pettmanug.site) and uses a proprietary [software licence](http://www.binpress.com/license/view/l/c8376a01eca7465027a978d3fde5a1e2). The SDKs are free to use in any project and have an ISC licence.  ## Bugs, features, support To report bugs or request features please see the [contact page](https://www.mailslurp.com/contact). For help see [support](https://www.mailslurp.com/support).
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var url = require("url");
var portableFetch = require("portable-fetch");
var BASE_PATH = "https://api.mailslurp.com".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(configuration, basePath, fetch) {
        if (basePath === void 0) { basePath = BASE_PATH; }
        if (fetch === void 0) { fetch = portableFetch; }
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
    return BaseAPI;
}());
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
var RequiredError = /** @class */ (function (_super) {
    __extends(RequiredError, _super);
    function RequiredError(field, msg) {
        var _this = _super.call(this, msg) || this;
        _this.field = field;
        return _this;
    }
    return RequiredError;
}(Error));
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace AccountDto
 */
var AccountDto;
(function (AccountDto) {
    /**
     * @export
     * @enum {string}
     */
    var AccountTypeEnum;
    (function (AccountTypeEnum) {
        AccountTypeEnum[AccountTypeEnum["FREE"] = 'FREE'] = "FREE";
        AccountTypeEnum[AccountTypeEnum["PAID"] = 'PAID'] = "PAID";
    })(AccountTypeEnum = AccountDto.AccountTypeEnum || (AccountDto.AccountTypeEnum = {}));
})(AccountDto = exports.AccountDto || (exports.AccountDto = {}));
/**
 * @export
 * @namespace UserDto
 */
var UserDto;
(function (UserDto) {
    /**
     * @export
     * @enum {string}
     */
    var AccountTypeEnum;
    (function (AccountTypeEnum) {
        AccountTypeEnum[AccountTypeEnum["FREE"] = 'FREE'] = "FREE";
        AccountTypeEnum[AccountTypeEnum["PAID"] = 'PAID'] = "PAID";
    })(AccountTypeEnum = UserDto.AccountTypeEnum || (UserDto.AccountTypeEnum = {}));
})(UserDto = exports.UserDto || (exports.UserDto = {}));
/**
 * AccountControllerApi - fetch parameter creator
 * @export
 */
exports.AccountControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * For use in dashboard
         * @summary Upgrade a user to paid
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {string} stripeToken Stripe user payment confirmation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionUsingPOST: function (jwtToken, stripeToken, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'jwtToken' is not null or undefined
            if (jwtToken === null || jwtToken === undefined) {
                throw new RequiredError('jwtToken', 'Required parameter jwtToken was null or undefined when calling createSubscriptionUsingPOST.');
            }
            // verify required parameter 'stripeToken' is not null or undefined
            if (stripeToken === null || stripeToken === undefined) {
                throw new RequiredError('stripeToken', 'Required parameter stripeToken was null or undefined when calling createSubscriptionUsingPOST.');
            }
            var localVarPath = "/subscription";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (jwtToken !== undefined) {
                localVarQueryParameter['jwtToken'] = jwtToken;
            }
            if (stripeToken !== undefined) {
                localVarQueryParameter['stripeToken'] = stripeToken;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For use in dashboard
         * @summary List available account types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsUsingGET: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/accounts";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountControllerApi - functional programming interface
 * @export
 */
exports.AccountControllerApiFp = function (configuration) {
    return {
        /**
         * For use in dashboard
         * @summary Upgrade a user to paid
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {string} stripeToken Stripe user payment confirmation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionUsingPOST: function (jwtToken, stripeToken, options) {
            var localVarFetchArgs = exports.AccountControllerApiFetchParamCreator(configuration).createSubscriptionUsingPOST(jwtToken, stripeToken, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * For use in dashboard
         * @summary List available account types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsUsingGET: function (options) {
            var localVarFetchArgs = exports.AccountControllerApiFetchParamCreator(configuration).getAccountsUsingGET(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AccountControllerApi - factory interface
 * @export
 */
exports.AccountControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * For use in dashboard
         * @summary Upgrade a user to paid
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {string} stripeToken Stripe user payment confirmation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionUsingPOST: function (jwtToken, stripeToken, options) {
            return exports.AccountControllerApiFp(configuration).createSubscriptionUsingPOST(jwtToken, stripeToken, options)(fetch, basePath);
        },
        /**
         * For use in dashboard
         * @summary List available account types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsUsingGET: function (options) {
            return exports.AccountControllerApiFp(configuration).getAccountsUsingGET(options)(fetch, basePath);
        },
    };
};
/**
 * AccountControllerApi - object-oriented interface
 * @export
 * @class AccountControllerApi
 * @extends {BaseAPI}
 */
var AccountControllerApi = /** @class */ (function (_super) {
    __extends(AccountControllerApi, _super);
    function AccountControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * For use in dashboard
     * @summary Upgrade a user to paid
     * @param {} jwtToken Cognito ID obtained during login
     * @param {} stripeToken Stripe user payment confirmation token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    AccountControllerApi.prototype.createSubscriptionUsingPOST = function (jwtToken, stripeToken, options) {
        return exports.AccountControllerApiFp(this.configuration).createSubscriptionUsingPOST(jwtToken, stripeToken, options)(this.fetch, this.basePath);
    };
    /**
     * For use in dashboard
     * @summary List available account types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    AccountControllerApi.prototype.getAccountsUsingGET = function (options) {
        return exports.AccountControllerApiFp(this.configuration).getAccountsUsingGET(options)(this.fetch, this.basePath);
    };
    return AccountControllerApi;
}(BaseAPI));
exports.AccountControllerApi = AccountControllerApi;
/**
 * InboxControllerApi - fetch parameter creator
 * @export
 */
exports.InboxControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a new random inbox and return the id and email address for it. Send emails to this address and they will be stored for this inbox.
         * @summary Create an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandomInboxUsingPOST: function (apiKey, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling createRandomInboxUsingPOST.');
            }
            var localVarPath = "/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an inbox and all the emails associated with it.
         * @summary Delete an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInboxUsingDELETE: function (apiKey, uuid, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling deleteInboxUsingDELETE.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid', 'Required parameter uuid was null or undefined when calling deleteInboxUsingDELETE.');
            }
            var localVarPath = "/inboxes/{uuid}"
                .replace("{" + "uuid" + "}", encodeURIComponent(String(uuid)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of emails stored in a given inbox. Each email contains various properties including the email body (in eml format), subject, and sender. The `since` parameter is a ISO8601 LocalDateTime that will filter for emails received on or after the given DateTime. Note that because an inbox may take 5 to 10 seconds to receive an email, you can use the `waitFor` parameter to hold a request open until the desired number of emails is present. If this number is not met after 100 seconds, an error will be returned.
         * @summary Fetch emails for a given inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {number} [minCount] Wait a maximum of 100 seconds for atleast this many emails in an inbox before returning a result.
         * @param {number} [maxWait] Maximum seconds API should spend retrying your inbox until the minCount is satisfied
         * @param {Date} [since] Filter for emails received on or after this ISO8601 LocalDateTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsForInboxUsingGET: function (apiKey, uuid, minCount, maxWait, since, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling getEmailsForInboxUsingGET.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid', 'Required parameter uuid was null or undefined when calling getEmailsForInboxUsingGET.');
            }
            var localVarPath = "/inboxes/{uuid}"
                .replace("{" + "uuid" + "}", encodeURIComponent(String(uuid)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }
            if (minCount !== undefined) {
                localVarQueryParameter['minCount'] = minCount;
            }
            if (maxWait !== undefined) {
                localVarQueryParameter['maxWait'] = maxWait;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of your inboxes. Each inbox has a uuid and an email address. Emails sent to the email address are stored in the inbox and can be fetched via `/inboxes/{uuid}`.
         * @summary List your inboxes
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfInboxesUsingGET: function (apiKey, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling getListOfInboxesUsingGET.');
            }
            var localVarPath = "/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from the given inbox's email address. Useful if you need to test a user contacting you, for instance.
         * @summary Send an email
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {SendEmailDto} sendEmailDto The email to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailFromUserUsingPOST: function (apiKey, uuid, sendEmailDto, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling sendEmailFromUserUsingPOST.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid', 'Required parameter uuid was null or undefined when calling sendEmailFromUserUsingPOST.');
            }
            // verify required parameter 'sendEmailDto' is not null or undefined
            if (sendEmailDto === null || sendEmailDto === undefined) {
                throw new RequiredError('sendEmailDto', 'Required parameter sendEmailDto was null or undefined when calling sendEmailFromUserUsingPOST.');
            }
            var localVarPath = "/inboxes/{uuid}"
                .replace("{" + "uuid" + "}", encodeURIComponent(String(uuid)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("SendEmailDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(sendEmailDto || {}) : (sendEmailDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * InboxControllerApi - functional programming interface
 * @export
 */
exports.InboxControllerApiFp = function (configuration) {
    return {
        /**
         * Create a new random inbox and return the id and email address for it. Send emails to this address and they will be stored for this inbox.
         * @summary Create an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandomInboxUsingPOST: function (apiKey, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).createRandomInboxUsingPOST(apiKey, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an inbox and all the emails associated with it.
         * @summary Delete an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInboxUsingDELETE: function (apiKey, uuid, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).deleteInboxUsingDELETE(apiKey, uuid, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of emails stored in a given inbox. Each email contains various properties including the email body (in eml format), subject, and sender. The `since` parameter is a ISO8601 LocalDateTime that will filter for emails received on or after the given DateTime. Note that because an inbox may take 5 to 10 seconds to receive an email, you can use the `waitFor` parameter to hold a request open until the desired number of emails is present. If this number is not met after 100 seconds, an error will be returned.
         * @summary Fetch emails for a given inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {number} [minCount] Wait a maximum of 100 seconds for atleast this many emails in an inbox before returning a result.
         * @param {number} [maxWait] Maximum seconds API should spend retrying your inbox until the minCount is satisfied
         * @param {Date} [since] Filter for emails received on or after this ISO8601 LocalDateTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsForInboxUsingGET: function (apiKey, uuid, minCount, maxWait, since, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getEmailsForInboxUsingGET(apiKey, uuid, minCount, maxWait, since, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of your inboxes. Each inbox has a uuid and an email address. Emails sent to the email address are stored in the inbox and can be fetched via `/inboxes/{uuid}`.
         * @summary List your inboxes
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfInboxesUsingGET: function (apiKey, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getListOfInboxesUsingGET(apiKey, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from the given inbox's email address. Useful if you need to test a user contacting you, for instance.
         * @summary Send an email
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {SendEmailDto} sendEmailDto The email to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailFromUserUsingPOST: function (apiKey, uuid, sendEmailDto, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).sendEmailFromUserUsingPOST(apiKey, uuid, sendEmailDto, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * InboxControllerApi - factory interface
 * @export
 */
exports.InboxControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a new random inbox and return the id and email address for it. Send emails to this address and they will be stored for this inbox.
         * @summary Create an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRandomInboxUsingPOST: function (apiKey, options) {
            return exports.InboxControllerApiFp(configuration).createRandomInboxUsingPOST(apiKey, options)(fetch, basePath);
        },
        /**
         * Delete an inbox and all the emails associated with it.
         * @summary Delete an inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInboxUsingDELETE: function (apiKey, uuid, options) {
            return exports.InboxControllerApiFp(configuration).deleteInboxUsingDELETE(apiKey, uuid, options)(fetch, basePath);
        },
        /**
         * Return a list of emails stored in a given inbox. Each email contains various properties including the email body (in eml format), subject, and sender. The `since` parameter is a ISO8601 LocalDateTime that will filter for emails received on or after the given DateTime. Note that because an inbox may take 5 to 10 seconds to receive an email, you can use the `waitFor` parameter to hold a request open until the desired number of emails is present. If this number is not met after 100 seconds, an error will be returned.
         * @summary Fetch emails for a given inbox
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {number} [minCount] Wait a maximum of 100 seconds for atleast this many emails in an inbox before returning a result.
         * @param {number} [maxWait] Maximum seconds API should spend retrying your inbox until the minCount is satisfied
         * @param {Date} [since] Filter for emails received on or after this ISO8601 LocalDateTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsForInboxUsingGET: function (apiKey, uuid, minCount, maxWait, since, options) {
            return exports.InboxControllerApiFp(configuration).getEmailsForInboxUsingGET(apiKey, uuid, minCount, maxWait, since, options)(fetch, basePath);
        },
        /**
         * Return a list of your inboxes. Each inbox has a uuid and an email address. Emails sent to the email address are stored in the inbox and can be fetched via `/inboxes/{uuid}`.
         * @summary List your inboxes
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfInboxesUsingGET: function (apiKey, options) {
            return exports.InboxControllerApiFp(configuration).getListOfInboxesUsingGET(apiKey, options)(fetch, basePath);
        },
        /**
         * Send an email from the given inbox's email address. Useful if you need to test a user contacting you, for instance.
         * @summary Send an email
         * @param {string} apiKey Your API Key. Sign up and find it in your dashboard.
         * @param {string} uuid The inbox&#39;s id.
         * @param {SendEmailDto} sendEmailDto The email to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailFromUserUsingPOST: function (apiKey, uuid, sendEmailDto, options) {
            return exports.InboxControllerApiFp(configuration).sendEmailFromUserUsingPOST(apiKey, uuid, sendEmailDto, options)(fetch, basePath);
        },
    };
};
/**
 * InboxControllerApi - object-oriented interface
 * @export
 * @class InboxControllerApi
 * @extends {BaseAPI}
 */
var InboxControllerApi = /** @class */ (function (_super) {
    __extends(InboxControllerApi, _super);
    function InboxControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new random inbox and return the id and email address for it. Send emails to this address and they will be stored for this inbox.
     * @summary Create an inbox
     * @param {} apiKey Your API Key. Sign up and find it in your dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.createRandomInboxUsingPOST = function (apiKey, options) {
        return exports.InboxControllerApiFp(this.configuration).createRandomInboxUsingPOST(apiKey, options)(this.fetch, this.basePath);
    };
    /**
     * Delete an inbox and all the emails associated with it.
     * @summary Delete an inbox
     * @param {} apiKey Your API Key. Sign up and find it in your dashboard.
     * @param {} uuid The inbox&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.deleteInboxUsingDELETE = function (apiKey, uuid, options) {
        return exports.InboxControllerApiFp(this.configuration).deleteInboxUsingDELETE(apiKey, uuid, options)(this.fetch, this.basePath);
    };
    /**
     * Return a list of emails stored in a given inbox. Each email contains various properties including the email body (in eml format), subject, and sender. The `since` parameter is a ISO8601 LocalDateTime that will filter for emails received on or after the given DateTime. Note that because an inbox may take 5 to 10 seconds to receive an email, you can use the `waitFor` parameter to hold a request open until the desired number of emails is present. If this number is not met after 100 seconds, an error will be returned.
     * @summary Fetch emails for a given inbox
     * @param {} apiKey Your API Key. Sign up and find it in your dashboard.
     * @param {} uuid The inbox&#39;s id.
     * @param {} [minCount] Wait a maximum of 100 seconds for atleast this many emails in an inbox before returning a result.
     * @param {} [maxWait] Maximum seconds API should spend retrying your inbox until the minCount is satisfied
     * @param {} [since] Filter for emails received on or after this ISO8601 LocalDateTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getEmailsForInboxUsingGET = function (apiKey, uuid, minCount, maxWait, since, options) {
        return exports.InboxControllerApiFp(this.configuration).getEmailsForInboxUsingGET(apiKey, uuid, minCount, maxWait, since, options)(this.fetch, this.basePath);
    };
    /**
     * Return a list of your inboxes. Each inbox has a uuid and an email address. Emails sent to the email address are stored in the inbox and can be fetched via `/inboxes/{uuid}`.
     * @summary List your inboxes
     * @param {} apiKey Your API Key. Sign up and find it in your dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getListOfInboxesUsingGET = function (apiKey, options) {
        return exports.InboxControllerApiFp(this.configuration).getListOfInboxesUsingGET(apiKey, options)(this.fetch, this.basePath);
    };
    /**
     * Send an email from the given inbox's email address. Useful if you need to test a user contacting you, for instance.
     * @summary Send an email
     * @param {} apiKey Your API Key. Sign up and find it in your dashboard.
     * @param {} uuid The inbox&#39;s id.
     * @param {} sendEmailDto The email to send.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.sendEmailFromUserUsingPOST = function (apiKey, uuid, sendEmailDto, options) {
        return exports.InboxControllerApiFp(this.configuration).sendEmailFromUserUsingPOST(apiKey, uuid, sendEmailDto, options)(this.fetch, this.basePath);
    };
    return InboxControllerApi;
}(BaseAPI));
exports.InboxControllerApi = InboxControllerApi;
/**
 * UserControllerApi - fetch parameter creator
 * @export
 */
exports.UserControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Used by the dashboard to fetch user information.
         * @summary Fetch a user
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET: function (jwtToken, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'jwtToken' is not null or undefined
            if (jwtToken === null || jwtToken === undefined) {
                throw new RequiredError('jwtToken', 'Required parameter jwtToken was null or undefined when calling getUserUsingGET.');
            }
            var localVarPath = "/user";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (jwtToken !== undefined) {
                localVarQueryParameter['jwtToken'] = jwtToken;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserControllerApi - functional programming interface
 * @export
 */
exports.UserControllerApiFp = function (configuration) {
    return {
        /**
         * Used by the dashboard to fetch user information.
         * @summary Fetch a user
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET: function (jwtToken, options) {
            var localVarFetchArgs = exports.UserControllerApiFetchParamCreator(configuration).getUserUsingGET(jwtToken, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * UserControllerApi - factory interface
 * @export
 */
exports.UserControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Used by the dashboard to fetch user information.
         * @summary Fetch a user
         * @param {string} jwtToken Cognito ID obtained during login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET: function (jwtToken, options) {
            return exports.UserControllerApiFp(configuration).getUserUsingGET(jwtToken, options)(fetch, basePath);
        },
    };
};
/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
var UserControllerApi = /** @class */ (function (_super) {
    __extends(UserControllerApi, _super);
    function UserControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Used by the dashboard to fetch user information.
     * @summary Fetch a user
     * @param {} jwtToken Cognito ID obtained during login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    UserControllerApi.prototype.getUserUsingGET = function (jwtToken, options) {
        return exports.UserControllerApiFp(this.configuration).getUserUsingGET(jwtToken, options)(this.fetch, this.basePath);
    };
    return UserControllerApi;
}(BaseAPI));
exports.UserControllerApi = UserControllerApi;
